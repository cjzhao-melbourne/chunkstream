import { MP4BoxInfo, SegmentInfo } from "../types";
import { backendService } from "./backendService";

export class ChunkstreamEngine {
  private file: File;
  private segmentDuration: number;
  private maxConcurrency: number;
  
  private videoId: string | null = null;
  private uploaderId: string | null = null;
  
  private mp4Info: MP4BoxInfo | null = null;
  private initFragment: Blob | null = null;
  private segmentFragments: Map<number, Blob> = new Map();
  private fragmentWaiters: Map<number, ((blob: Blob) => void)[]> = new Map();
  private fragmentGenerationDone = false;
  private segments: SegmentInfo[] = [];
  private inFlight = new Set<number>();
  private stopRequested = false;
  private totalDurationSec = 0;

  // Callbacks for UI updates
  onProgress: (segments: SegmentInfo[]) => void = () => {};
  onLog: (msg: string) => void = () => {};
  onReadyToPlay: (url: string, videoId: string) => void = () => {};

  constructor(file: File, options: { segmentDuration?: number; maxConcurrency?: number } = {}) {
    this.file = file;
    this.segmentDuration = options.segmentDuration || 10;
    this.maxConcurrency = options.maxConcurrency || 3;
  }

  log(msg: string) {
    console.log(`[Chunkstream] ${msg}`);
    this.onLog(msg);
  }

  async start() {
    try {
      this.log("Starting streaming fragmentation (memory-lite)...");

      // 1. Start streaming fragmenter; wait until moov + init ready
      const { readyPromise } = this.startStreamingFragmenter();
      const { info, initSegment, durationSec, segmentCount } = await readyPromise;
      this.mp4Info = info;
      this.totalDurationSec = durationSec;
      this.initFragment = new Blob([initSegment], { type: "video/iso.segment" });

      // Build placeholder segment list (fragments arrive asynchronously)
      this.segments = Array.from({ length: segmentCount }).map((_, idx) => {
        const startTime = idx * this.segmentDuration;
        const endTime = Math.min(durationSec, startTime + this.segmentDuration);
        return {
          index: idx,
          startTime,
          endTime,
          startByte: 0,
          endByte: 0,
          duration: endTime - startTime,
          status: 'pending'
        };
      });
      this.onProgress([...this.segments]);

      this.log(`MOOV parsed. Init ready. Duration ${durationSec.toFixed(2)}s, ~${segmentCount} segments planned.`);

      // 2. Initialize Backend Session
      const { video_id } = await backendService.initSession(
        this.file.name,
        this.file.size,
        segmentCount,
        this.segmentDuration
      );
      this.videoId = video_id;
      this.log(`Session initialized. Video ID: ${this.videoId}`);

      // 3. Upload init segment (ftyp/moov + mvex) generated by mp4box
      await this.uploadInitSegment();

      // 4. Register Uploader (get uploader id and start scheduler work)
      const { uploader_id } = await backendService.registerUploader(this.videoId, this.maxConcurrency);
      this.uploaderId = uploader_id;
      this.log(`Uploader registered. ID: ${this.uploaderId}`);

      // 5. Start Loop (uploads run in background)
      this.scheduleLoop();

      // 6. Generate and Upload MPD
      const mpd = this.generateDASHManifest(info, this.segments);
      this.log(`Generated MPD:\n${mpd}`);
      await backendService.uploadManifest(this.videoId, mpd);
      this.log("Manifest uploaded.");

      // 7. Notify Player only after the first segment is available (or timeout)
      await this.waitForSegmentCompletion(0, 20000);
      this.onReadyToPlay(backendService.getManifestUrl(this.videoId), this.videoId);

    } catch (err: any) {
      this.log(`Error: ${err.message}`);
      console.error(err);
    }
  }

  stop() {
    this.stopRequested = true;
  }

  private generateDASHManifest(info: MP4BoxInfo, segments: SegmentInfo[]): string {
    const duration = (info.duration / info.timescale).toFixed(2);
    // Assuming AVC1 video for MVP, retrieving real codec string from MP4Box is better
    const videoTrack = info.videoTracks[0];
    const codec = videoTrack?.codec || "avc1.42E01E";
    const width = videoTrack?.track_width || 640;
    const height = videoTrack?.track_height || 360;
    const bandwidth = videoTrack?.bitrate || 1000000; // Default 1Mbps if unknown
    
    // Simple static DASH MPD
    return `<?xml version="1.0" encoding="UTF-8"?>
<MPD xmlns="urn:mpeg:dash:schema:mpd:2011" type="static" minBufferTime="PT2S" mediaPresentationDuration="PT${duration}S" profiles="urn:mpeg:dash:profile:isoff-on-demand:2011">
  <Period id="1" start="PT0S">
    <AdaptationSet mimeType="video/mp4" segmentAlignment="true" startWithSAP="1">
      <Representation id="1" BANDWIDTH="${bandwidth}" codecs="${codec}" width="${width}" height="${height}" frameRate="30">
        <SegmentTemplate initialization="init.m4s" timescale="1" duration="${this.segmentDuration}" media="segment_$Number$.m4s" startNumber="0" />
      </Representation>
    </AdaptationSet>
  </Period>
</MPD>`;
  }

  private async scheduleLoop() {
    this.log("Starting scheduling loop...");
    while (!this.stopRequested) {
      // Check if all done
      const allDone = this.segments.every(s => s.status === 'completed');
      if (allDone) {
        this.log("All segments uploaded!");
        break;
      }

      const slotsAvailable = this.maxConcurrency - this.inFlight.size;
      if (slotsAvailable <= 0) {
        await this.sleep(200);
        continue;
      }

      try {
        const { tasks } = await backendService.getNextTasks(
          this.videoId!, 
          this.uploaderId!, 
          slotsAvailable, 
          Array.from(this.inFlight)
        );

        if (!tasks || tasks.length === 0) {
          await this.sleep(1000); // Wait for tasks
          continue;
        }

        for (const task of tasks) {
          if (this.inFlight.has(task.index)) continue;
          
          // Mark as uploading
          this.updateSegmentStatus(task.index, 'uploading');
          this.inFlight.add(task.index);
          
          // Trigger upload (async, don't await here to allow concurrency)
          this.processTask(task.index).catch(err => {
            this.log(`Task ${task.index} failed: ${err.message}`);
            this.updateSegmentStatus(task.index, 'error');
          }).finally(() => {
            this.inFlight.delete(task.index);
          });
        }

      } catch (e) {
        console.error(e);
        await this.sleep(2000);
      }
    }
  }

  private async processTask(index: number) {
    const segment = this.segments.find(s => s.index === index);
    if (!segment) return;
    const fragment = await this.waitForFragment(index, 20000);
    if (!fragment) return;

    this.log(`Processing segment ${index} (${segment.startTime.toFixed(2)}-${segment.endTime.toFixed(2)}s)`);

    const formData = new FormData();
    formData.append("segment", fragment, `segment_${index}.m4s`);
    formData.append("index", index.toString());
    formData.append("start_time", segment.startTime.toString());
    formData.append("end_time", segment.endTime.toString());

    await backendService.uploadSegment(this.videoId!, formData);
    
    this.updateSegmentStatus(index, 'completed');
    this.log(`Segment ${index} uploaded.`);

    // Free memory after upload
    this.segmentFragments.delete(index);
  }

  private updateSegmentStatus(index: number, status: SegmentInfo['status']) {
    const segIndex = this.segments.findIndex(s => s.index === index);
    if (segIndex !== -1) {
      this.segments[segIndex].status = status;
      this.onProgress([...this.segments]);
    }
  }

  private sleep(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private async uploadInitSegment() {
    if (!this.videoId) {
      throw new Error("videoId missing before uploading init segment");
    }
    if (!this.initFragment) {
      throw new Error("Init fragment missing; fragmentation did not run");
    }
    const formData = new FormData();
    formData.append("init", this.initFragment, "init.m4s");
    await backendService.uploadInit(this.videoId, formData);
    this.log(`Init segment uploaded (${this.initFragment.size} bytes).`);
  }

  private async waitForSegmentCompletion(index: number, timeoutMs = 15000) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      const seg = this.segments.find(s => s.index === index);
      if (seg?.status === 'completed') return;
      if (this.stopRequested) return;
      await this.sleep(200);
    }
    this.log(`Timeout waiting for segment ${index} to complete; proceeding anyway.`);
  }

  /**
   * Streaming fragmentation with mp4box.js: reads file in small chunks, emits init + segments progressively.
   */
  private startStreamingFragmenter(): {
    readyPromise: Promise<{ info: MP4BoxInfo; initSegment: ArrayBuffer; durationSec: number; segmentCount: number }>;
  } {
    const MP4Box = (window as any).MP4Box;
    if (!MP4Box || typeof MP4Box.createFile !== "function") {
      throw new Error("mp4box.js not available");
    }

    const readyPromise = new Promise<{
      info: MP4BoxInfo;
      initSegment: ArrayBuffer;
      durationSec: number;
      segmentCount: number;
    }>((resolve, reject) => {
      const mp4boxFile = MP4Box.createFile();
      let info: MP4BoxInfo | null = null;
      let initSegment: ArrayBuffer | null = null;
      let videoTrackId: number | null = null;
      let durationSec = 0;
      let segmentIndex = 0;

      const CHUNK_SIZE = 1024 * 1024; // 1MB per read

      const feedChunks = async () => {
        let offset = 0;
        while (offset < this.file.size) {
          if (this.stopRequested) break;
          const end = Math.min(offset + CHUNK_SIZE, this.file.size);
          const buf = await this.file.slice(offset, end).arrayBuffer();
          (buf as any).fileStart = offset;
          mp4boxFile.appendBuffer(buf);
          offset = end;
        }
        mp4boxFile.flush();
        this.fragmentGenerationDone = true;
      };

      mp4boxFile.onError = (e: any) => {
        reject(new Error(typeof e === "string" ? e : (e?.message || "mp4box error")));
      };

      mp4boxFile.onReady = (i: MP4BoxInfo) => {
        info = i;
        const videoTrack = i.videoTracks[0];
        if (!videoTrack) {
          reject(new Error("No video track found"));
          return;
        }
        videoTrackId = videoTrack.id;
        durationSec = i.duration / i.timescale;
        const segmentCount = Math.ceil(durationSec / this.segmentDuration);

        mp4boxFile.setSegmentOptions(videoTrackId, null, {
          segmentDuration: this.segmentDuration,
          rapAligned: true
        });
        const initSegs = mp4boxFile.initializeSegmentation();
        mp4boxFile.start();
        const initInfo = initSegs[videoTrackId];
        if (!initInfo || !initInfo.buffer) {
          reject(new Error("Failed to generate init segment"));
          return;
        }
        initSegment = initInfo.buffer;
        resolve({ info, initSegment, durationSec, segmentCount });
      };

      mp4boxFile.onSegment = (_id: number, _user: any, buffer: ArrayBuffer, sampleNum: number, isLast: boolean) => {
        const startTime = segmentIndex * this.segmentDuration;
        const endTime = Math.min(durationSec || startTime + this.segmentDuration, startTime + this.segmentDuration);
        const blob = new Blob([buffer], { type: "video/iso.segment" });
        this.segmentFragments.set(segmentIndex, blob);
        this.notifyFragmentReady(segmentIndex, blob);
        segmentIndex += 1;
        if (videoTrackId !== null) {
          mp4boxFile.releaseUsedSamples(videoTrackId, sampleNum);
        }
        if (isLast) {
          this.fragmentGenerationDone = true;
        }
      };

      // Begin streaming read (async, not awaited here)
      feedChunks().catch(err => reject(err));
    });

    return { readyPromise };
  }

  private notifyFragmentReady(index: number, blob: Blob) {
    const waiters = this.fragmentWaiters.get(index);
    if (waiters) {
      waiters.forEach(res => res(blob));
      this.fragmentWaiters.delete(index);
    }
  }

  private waitForFragment(index: number, timeoutMs = 15000): Promise<Blob | null> {
    const existing = this.segmentFragments.get(index);
    if (existing) return Promise.resolve(existing);

    return new Promise(resolve => {
      const waiters = this.fragmentWaiters.get(index) || [];
      waiters.push(resolve);
      this.fragmentWaiters.set(index, waiters);
      setTimeout(() => {
        const late = this.segmentFragments.get(index);
        if (late) {
          resolve(late);
        } else {
          this.log(`Timeout waiting for fragment ${index}`);
          resolve(null);
        }
      }, timeoutMs);
    });
  }
}
